
1.  Здравствуйте. Этот текст был сгенерирован шаблонной системой.
    Каким образом можно распознать текстовый блок, такой, как, например,
    этот? Все очень просто! По отстутстию специальных символов шаблонной
    системы. В этом абзаце нет специальных заголовков шаблонной системы,
    поэтому он должен распознаваться как текст. Особое внимание должно 
    уделяться форматированию текста: оно должно в точности соответствовать
    форматированию текста в исходном шаблоне.
    
2.  А в этом абзаце я обращусь к вам по имени, [[name]]. В результирующем
    тексте вы не увидите заголовок "цепочки", но взглянув в исодный код
    его можно увидеть в том месте, где сейчас написано ваше имя. Правило
    для этого блока довольно простое - заголовок цепочки заменяется на
    результат её отрисовки. А что, если результат обработки цепочки занимает
    несколько строк текста? Сейчас увидим!
    
3.  Возьмем в качестве примера стихотворение Александра Сергеевича Пушкина:
    "Мой дядя самых честных правил,
    Когда не в шутку занемог,
    Он уважать себя заставил
    И лучше выдумать не мог.
    Его пример другим наука;
    Но, боже мой, какая скука
    С больным сидеть и день и ночь,
    Не отходя ни шагу прочь!
    Какое низкое коварство
    Полу-живого забавлять,
    Ему подушки поправлять,
    Печально подносить лекарство,
    Вздыхать и думать про себя:
    Когда же чорт возьмет тебя!"
    
    Вдохновившись произведением мэтра начинаем анализировать оформление.
    Первым делом обратим внимание на отступы в начале каждой строки. Ведь
    мы хотим получить красивый результат отрисовки, правильно? Допустим, что
    мы читаем текст стихотворения из файла, где перед строками нет оступов.
    Что будет, если мы напишем в шаблонной системе, не учитывающей отступы,
    [[poetry]]? А вот что!
    "Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.
..."""
    
    Ведь это не совсем то, что нам нужно? Нужно подумать...
    Когда мы пишем:
____[[poetry]], заголовок имеет отступ, (обозначенный как "____"), который
    распознается системой как тект, так как не имеет заголовков других
    объектов. Есть вариант запоминать этот отступ при распознавании шаблона
    и использовать его при отрисовке многострочных блоков текста, добавляя
    отступ ко всем строкам, кроме первой. Тогда получится:
    "Мой дядя самых честных правил,
____Когда не в шутку занемог,
____Он уважать себя заставил
____И лучше выдумать не мог.
____..."
    Это уже гораздо лучше! Таким образом необходимо добавить в шаблонную систему
    механизм отрисовки цепочек с отступами. (а также механизм определения этих
    самых отступов)
    
4.  Далее сложнее. При отрисовке блочных токенов мы должны заботиться об 
    отступах еще больше. Это требует отдельного мозгового штурма.
    Допустим, что я хочу вывести стихотворение построчно. И получить тот-
    же эффект, что был бы при отрисовке через цепочку. Помним, что текст у нас
    дан без отступов. Поехали!
    
    ############################
    {{for line in poetryLines}}
        [[line]]
    {{end}}
    ############################
    
    Теперь займемся анализом. Определим участки кода, которые шаблонная система
    считает текстом:
    
    ############################
__1__{{for line in poetryLines}}\n
____2____[[line]]\n
__3__{{end}}\n
    ############################
    
    В этом фрагмете система считает текстом отступ перед for и после end,
    содержание блока, а так- же три символа новой строки. Что получится, если
    мы будем действовать в лоб?
    
    ############################
__1__
\n
____2____Мой дядя самых честных правил,
\n
__3___
\n
____2____Когда не в шутку занемог,
\n
__3___
\n
    ############################
    
    Это не совсем то, чего нам хочется. Как же решить эту проблему?
    Во прервых необходимо разделить два случая отрисовки:
    
        1. Однострочный блок, например:
            {{for x in 100}}100{{end}}
        2. Многострочный блок.
        
    Сейчас рассмотрим многострочные блоки. Во прервых, я предлагаю
    отбрасывать следующий текст:
    ############################
    {{for line in poetryLines}}>>\n<<
        [[line]]\n
>>____<<{{end}}>>\n<<<
    ############################
    
    Это позволяет нам решить проблему с ненужными переводами строки
    и лишними отступами. Далее рассмотрим оставшийся фрагмент:
    
    ############################
__1__ __2__{{line}}\n
    ############################
    (1) достется по наследству от самого блока for, это его отступ.
    (2) собственный отступ внутри блока.
    Предлагается игнорировать отступ __2__ менее 4х пробелов для удобства
    табуляции, и считать системой отчета бОльших отступов считать 4й пробел.
    Дополнительно к этому предлагается игнорировать __1__ в первой строке.
    Таким образом при выводе:
    
    ############################
    {{for line in poetryLines}}
        [[line]]
    {{end}}
    ############################
    
    Мы получим ожидаемый результат:
    "Мой дядя самых честных правил,
    Когда не в шутку занемог,
    Он уважать себя заставил
    И лучше выдумать не мог.
    ..."
    
    Те- же правила пусть действуют на другие типы блоков.

